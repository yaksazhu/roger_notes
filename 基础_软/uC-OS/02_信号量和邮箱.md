# 1. uC/OS II信号量和邮箱简介
多个任务在运行时,
1. 共享资源
2. 互相依赖
3. 互相制约
## 1.1 事件
任务间的同步依赖于任务间的通信。
在UCOSII中，使用信号量、邮箱和消息队列来实现任务之间的通信。
信号量、邮箱和消息队列被称作"**事件**"
发送事件: 任务1负责把信息发送到事件上
请求事件: 任务2通过读取事件操作对事件进行查询 ---- 如果有信息则读取，否则等待。
```
 +-------+  发送事件  +------+  请求事件  +-------+
 | 任务1 | ---------> | 事件 | ---------> | 任务2 |
 +-------+            +------+            +-------+
```

## 1.2 事件控制块ECB
UCOSII使用事件控制块(ECB)数据结构来描述诸如信号量、邮箱（消息邮箱）和消息队列这些事件
OS_EVENT结构体包括:
* OSEventType 事件的类型
* OSEventCnt  信号量计数器
* OSEventPtr  消息或消息队列的指针
* OSEventGrp  等待事件的任务组
* OSEventTbl[] 任务等待表
* OSEventName 事件名

## 1.3 信号量
信号量是一类事件。
使用信号量的最初目的，是为了给共享资源设立一个标志，表示该资源的占用情况。
信号量可分为两种：二值信号量，N值信号量。 (互斥型信号量 & 计数型信号量)
OSSemCreate() & OSSemDel()
OSSemPost()
OSSemPend()

## 1.4 邮箱
任务间通过传递一个数据（消息）的方式来进行通信。
可以在内存中创建一个消息缓冲区，这样传递消息的最简单办法就是传递消息缓冲区的指针。
把用来传递消息缓冲区指针的数据结构叫做邮箱（消息邮箱）。

通过事件控制块的OSEventPrt来传递消息缓冲区指针，同时使事件控制块的成员OSEventType为OS_EVENT_TYPE_MBOX，则该事件控制块就叫做消息邮箱。
OSMboxCreate() & OSMboxDel()
OSMboxPost() 向邮箱发送消息
OSMboxPend() 请求邮箱
OSMboxQuery() 查询邮箱的当前状态

# 2. 硬件设计
创建6个任务：开始任务、LED 任务、触摸屏任务、蜂鸣器任务、按键扫描任务和主任务
1. start_task 开始任务用于创建信号量、创建邮箱、初始化统计任务以及其他任务的创建，之后挂起；
2. led_task   LED任务用于DS0控制，提示程序运行状况；
3. beep_task  蜂鸣器任务用于测试信号量，是请求信号量函数，每得到一个信号量，蜂鸣器就叫一次；
4. touch_task 触摸屏任务用于在屏幕上画图，可以用于测试CPU使用率；
5. key_task   按键扫描任务用于按键扫描，优先级最高，将得到的键值通过消息邮箱发送出去；
6. main_task  主任务则通过查询消息邮箱获得键值，并根据键值执行DS1控制、信号量发送（蜂鸣器控制）、触摸区域清屏和触摸屏校准等控制。

# 3. 软件设计
1. 消息邮箱msg_key，用于按键任务和主任务之间的数据传输（传递键值）
2. 信号量sem_beep，用于蜂鸣器任务和主任务之间的通信。
3. 在主任务中，用到了任务的挂起和恢复函数
> 在执行触摸屏校准的时候，必须先将触摸屏任务挂起，待校准完成之后，再恢复触摸屏任务。
> 这是因为触摸屏校准和触摸屏任务都用到了触摸屏和TFTLCD，而这两个东西是不支持多个任务占用的，所以必须采用独占的方式使用，否则可能导致数据错乱。

# 4. 验证
默认状态下，CPU使用率仅为2%。
* 通过在触摸区域画图，可以看到CPU使用率飙升(20%多)，说明触摸屏任务是一个很占CPU的任务；
* 通过按KEY0，可以控制DS1的亮灭；
* 通过按KEY1，可以控制蜂鸣器的发声（连续按下多次后，可以看到蜂鸣每隔1秒叫一次），
* 可以在LCD上面看到信号量的当前值；
* 通过按KEY2，可以清除触摸屏的输入；
* 通过按KEY_UP可以进入校准程序，进行触摸屏校准。
